add wallet infrastructure
add sign(address, msg) using wallet infrastrucure
report test vectors from P. Todd's library
report trailing/leading blank trimming in Electrum message signing

isinstance(entr, bytearray): 
or 
isinstance(entr, bytes):

verify all isinstance for bytesize (what is hexstring is short?)

readthedocs [![Documentation Status](https://readthedocs.org/projects/btclib/badge/?version=latest)](https://btclib.readthedocs.io/)
revise ansi_x963_kdf
optimizations
    https://cryptojedi.org/peter/data/eccss-20130911b.pdf
    https://arxiv.org/abs/1801.08589
    https://ecc2017.cs.ru.nl/slides/ecc2017school-castryck.pdf
    https://hal.archives-ouvertes.fr/hal-00932199/document
    https://iacr.org/workshops/ches/ches2006/presentations/Douglas%20Stebila.pdf
    https://eprint.iacr.org/2005/419.pdf
transaction and block parsing (explorer based with optional full node)
allow hexstring for Signature
revise ssa.pubkey_recovery
of a signature: verify or verification ? of a commit: verify or open ?
crack https://bitcoinmagazine.com/articles/deterministic-wallets-advantages-flaw-1385450276/
better mimic of electrum entropy search, they probably have the words inverted
BIP44 in address_from...

opposite in Jac coordinate using y_quadratic_residue ?

primitives for interactive threshold and musig

generalize ec, hf in borromean

Edwards curve (Curve25519)

BLS

reference borromean
deserialize curves from jason file
serialized signatures
add der serialize/deserialize to dsa
add signature serialize/deserialize
remove signtocontract, adding commit to dsa and ssa
e=0 in SSA ?

crypto: {
    prv, q: int,
    pub, Q: Point
}

(bitcoin) network: {
    Octets: Union[bytes, str],   # bytes or hex-string (not string)
    prvkey: Octets,
    pubkey, Q: Union[Point, Octets],
    DER: Octets,
    ECDSA Sig = Union[Tuple[int, int], Octets],  # (r, s) or DER serialization
    BTCMSG Sig = Union[Tuple[int, int, int], Octets],  # (rec_flag, r, s) or compact serialization
    h160, h256: Octets
    version, sighash: Octets 
    msg: Union[bytes, str]  # string to be encoded, not hex-string, never s.strip()
    address, WIF: Union[bytes, str]  # ASCII string to be encoded, not hex-string, always s.strip()
}

