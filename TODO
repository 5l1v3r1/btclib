add wallet infrastructure
add sign(address, msg) using wallet infrastrucure
report test vectors from P. Todd's library
report trailing/leading blank trimming in Electrum message signing

isinstance(entr, bytearray):
or
isinstance(entr, bytes):

verify all isinstance for bytesize (what if hexstring is short?)

revise ansi_x963_kdf
optimizations
    https://cryptojedi.org/peter/data/eccss-20130911b.pdf
    https://arxiv.org/abs/1801.08589
    https://ecc2017.cs.ru.nl/slides/ecc2017school-castryck.pdf
    https://hal.archives-ouvertes.fr/hal-00932199/document
    https://iacr.org/workshops/ches/ches2006/presentations/Douglas%20Stebila.pdf
    https://eprint.iacr.org/2005/419.pdf
transaction and block parsing (explorer based with optional full node)
revise ssa.pubkey_recovery
of a signature: verify or verification ? of a commit: verify or open ?
crack https://bitcoinmagazine.com/articles/deterministic-wallets-advantages-flaw-1385450276/
better mimic of electrum entropy search, they probably have the words inverted
BIP44 in address_from...

opposite in Jac coordinate using y_quadratic_residue ?

primitives for interactive threshold and musig

generalize ec, hf in borromean

Edwards curve (Curve25519)

BLS

reference borromean
deserialize curves from jason file
add signature serialize/deserialize to SSA
remove signtocontract, adding commit to dsa and ssa
e=0 in SSA ?

remove checks from _functions

    ## pure crypto
    Point = Tuple[int, int]

    prvkey, prv, q: int
    pubkey, pub, Q: Point


    # bytes or text string (not hex-string)
    # always encode to convert to bytes
    msg: Union[bytes, str]      # text message, do not s.strip()

    # bytes or text string (not hex-string)
    # no need to encode to bytes as b58decode will take care
    b58addr: Union[bytes, str]       # always s.strip()

    # bytes or text string (not hex-string)
    # always encode to convert to bytes
    b32addr: Union[bytes, str]  # bech32, always s.strip()
    wif: Union[bytes, str]      # WIF, always s.strip()
    xkey: Union[bytes, str]     # BIP32, always s.strip()


    # bytes or hex-string (not text string)
    # always use bytes_from_hexstring to convert to bytes
    Octets = Union[bytes, str]
    script: Octets        # variable length
    h160: Octets          # 20 bytes
    h256: Octets          # 32 bytes
    bip32version: Octets  # 4 byte
    sighash: Octets       # 1 byte
    # ECDSA signature with DER serialization, with or without sighash
    dersig: Octets        # 9-73 bytes
    # Bitcoin message compact signature serialization
    msgsig: Octets        # 65 bytes

    # BIP32 xkey (bytes, string, or XkeyDict), WIF (bytes or string), Octets, native int
    prvkey, prv, q: Union[int, bip32.XkeyDict, bytes, str]  # to_prv_int

    # BIP32 xkey (bytes, string, or XkeyDict), Octets, native tuple
    pubkey, pub, Q: Union[Point, bip32.XkeyDict, bytes, str]  # to_pub_tuple or to_pub_bytes

    dersig: Tuple[int, int, bytes]  # (r, s, sighash)
    dsasig = Union[Tuple[int, int], Octets]  # (r, s) or DER serialization
    msgsig = Union[Tuple[int, int, int], Octets]  # (rf, r, s) or compact serialization

}

